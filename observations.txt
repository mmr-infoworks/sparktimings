1.Check plans for hive and spark
2.Check execution for spark for each of the queries.

1.Query1 ~ 7s
SELECT STORE_FLATTENED.CLX_IRI_MARKET_AREA AS CLX_IRI_MARKET_AREA
 ,STORE_FLATTENED.IDR_DFLT_WHSE AS IDR_DFLT_WHSE
 ,POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK AS SALES_AMT_LAST_WK
 ,ITEM_FLATTEN.SUPPLIER AS SUPPLIER
 FROM 8N_POS_INV_DASHBOARD_CUBE.POS_INV_FACT_ROLLUP POS_INV_FACT_ROLLUP LEFT OUTER JOIN
 8N_POS_INV_DASHBOARD_CUBE.STORE_FLATTENED STORE_FLATTENED
 ON (POS_INV_FACT_ROLLUP.WMSTRNBR = STORE_FLATTENED.WM_STR_NBR__STORE_CLEANED)
 JOIN 8N_POS_INV_DASHBOARD_CUBE.ITEM_FLATTEN ITEM_FLATTEN
 ON (POS_INV_FACT_ROLLUP.WM_ITEM_NBR = ITEM_FLATTEN.WM_ITEM_NBR)
 LEFT JOIN 8N_POS_INV_DASHBOARD_CUBE.WM_M_CAL_WEEK_2 WM_M_CAL_WEEK_2
 ON (POS_INV_FACT_ROLLUP.WM_WK = WM_M_CAL_WEEK_2.WM_WK) WHERE WM_M_CAL_WEEK_2.WM_WK = 201634
  GROUP BY STORE_FLATTENED.CLX_IRI_MARKET_AREA
 ,STORE_FLATTENED.IDR_DFLT_WHSE
 ,POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK
 ,ITEM_FLATTEN.SUPPLIER;

 2. Query 2 ~ 7s 
 SELECT STORE_FLATTENED.CLX_IRI_MARKET_AREA AS CLX_IRI_MARKET_AREA
 ,STORE_FLATTENED.IDR_DFLT_WHSE AS IDR_DFLT_WHSE
 ,POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK AS SALES_AMT_LAST_WK
 ,ITEM_FLATTEN.SUPPLIER AS SUPPLIER
 FROM 8N_POS_INV_DASHBOARD_CUBE.POS_INV_FACT_ROLLUP POS_INV_FACT_ROLLUP LEFT OUTER JOIN
 8N_POS_INV_DASHBOARD_CUBE.STORE_FLATTENED STORE_FLATTENED
 ON (POS_INV_FACT_ROLLUP.WMSTRNBR = STORE_FLATTENED.WM_STR_NBR__STORE_CLEANED)
 JOIN 8N_POS_INV_DASHBOARD_CUBE.ITEM_FLATTEN ITEM_FLATTEN
 ON (POS_INV_FACT_ROLLUP.WM_ITEM_NBR = ITEM_FLATTEN.WM_ITEM_NBR)
 LEFT JOIN 8N_POS_INV_DASHBOARD_CUBE.WM_M_CAL_WEEK_2 WM_M_CAL_WEEK_2
 ON (POS_INV_FACT_ROLLUP.WM_WK = WM_M_CAL_WEEK_2.WM_WK) WHERE POS_INV_FACT_ROLLUP.WM_WK = 201634
  GROUP BY STORE_FLATTENED.CLX_IRI_MARKET_AREA
 ,STORE_FLATTENED.IDR_DFLT_WHSE
 ,POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK
 ,ITEM_FLATTEN.SUPPLIER;

 Observation : Both query 1 and query 2 do an inmemory table scan outputting only relevant rows (~1,382,000)

 3.Query 3 ~ 7s 
  EXPLAIN SELECT STORE_FLATTENED.CLX_IRI_MARKET_AREA AS CLX_IRI_MARKET_AREA
,STORE_FLATTENED.IDR_DFLT_WHSE AS IDR_DFLT_WHSE
,POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK AS SALES_AMT_LAST_WK
,ITEM_FLATTEN.SUPPLIER AS SUPPLIER
FROM 8N_POS_INV_DASHBOARD_CUBE.POS_INV_FACT_ROLLUP POS_INV_FACT_ROLLUP
LEFT OUTER JOIN 8N_POS_INV_DASHBOARD_CUBE.STORE_FLATTENED STORE_FLATTENED
ON (POS_INV_FACT_ROLLUP.WMSTRNBR = STORE_FLATTENED.WM_STR_NBR__STORE_CLEANED)
 JOIN 8N_POS_INV_DASHBOARD_CUBE.ITEM_FLATTEN ITEM_FLATTEN
  ON (POS_INV_FACT_ROLLUP.WM_ITEM_NBR = ITEM_FLATTEN.WM_ITEM_NBR)
  LEFT JOIN 8N_POS_INV_DASHBOARD_CUBE.WM_M_CAL_WEEK_2 WM_M_CAL_WEEK_2
  ON (POS_INV_FACT_ROLLUP.WM_WK = WM_M_CAL_WEEK_2.WM_WK)
  WHERE POS_INV_FACT_ROLLUP.cost_amt_lyr_last_wk > 1000
  GROUP BY STORE_FLATTENED.CLX_IRI_MARKET_AREA
,STORE_FLATTENED.IDR_DFLT_WHSE
,POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK
,ITEM_FLATTEN.SUPPLIER LIMIT 100;

Observation : Does an inmemory scan of 17,530,862M rows

4. query 4 ~ 4s
SELECT STORE_FLATTENED.CLX_IRI_MARKET_AREA AS CLX_IRI_MARKET_AREA 
STORE_FLATTENED.IDR_DFLT_WHSE AS IDR_DFLT_WHSE 
POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK AS SALES_AMT_LAST_WK 
ITEM_FLATTEN.SUPPLIER AS SUPPLIER 
FROM 8N_POS_INV_DASHBOARD_CUBE.POS_INV_FACT_ROLLUP POS_INV_FACT_ROLLUP 
LEFT OUTER JOIN 8N_POS_INV_DASHBOARD_CUBE.STORE_FLATTENED STORE_FLATTENED
 ON (POS_INV_FACT_ROLLUP.WMSTRNBR = STORE_FLATTENED.WM_STR_NBR__STORE_CLEANED)
 JOIN 8N_POS_INV_DASHBOARD_CUBE.ITEM_FLATTEN ITEM_FLATTEN 
 ON (POS_INV_FACT_ROLLUP.WM_ITEM_NBR = ITEM_FLATTEN.WM_ITEM_NBR)
  LEFT JOIN 8N_POS_INV_DASHBOARD_CUBE.WM_M_CAL_WEEK_2 WM_M_CAL_WEEK_2 
  ON (POS_INV_FACT_ROLLUP.WM_WK = WM_M_CAL_WEEK_2.WM_WK) 
  WHERE POS_INV_FACT_ROLLUP.sales_amt_last_wk > 10 GROUP BY STORE_FLATTENED.CLX_IRI_MARKET_AREA 
STORE_FLATTENED.IDR_DFLT_WHSE 
POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK 
ITEM_FLATTEN.SUPPLIER LIMIT 100

Similar to query 3 but does inmemory scan of 270 m rows

5. Query 5 sames as Query1 but removing cache ~5 s
   Does a Hive Table scan of 1382000 rows
6. Query 6 same as Query2 but removing cache ~ 6s
   Does a hive table scan of 1382000 rows
7. Query 7 same as Query4 but removing cache ~ 14 s
   Does a hive table scan of 280,000,000 rows

8. select count(*) from
(SELECT 
STORE_FLATTENED.CLX_IRI_MARKET_AREA AS CLX_IRI_MARKET_AREA
 ,STORE_FLATTENED.IDR_DFLT_WHSE AS IDR_DFLT_WHSE
 ,POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK AS SALES_AMT_LAST_WK
 ,ITEM_FLATTEN.SUPPLIER AS SUPPLIER
 FROM 8N_POS_INV_DASHBOARD_CUBE.POS_INV_FACT_ROLLUP POS_INV_FACT_ROLLUP LEFT OUTER JOIN
 8N_POS_INV_DASHBOARD_CUBE.STORE_FLATTENED STORE_FLATTENED
 ON (POS_INV_FACT_ROLLUP.WMSTRNBR = STORE_FLATTENED.WM_STR_NBR__STORE_CLEANED)
 JOIN 8N_POS_INV_DASHBOARD_CUBE.ITEM_FLATTEN ITEM_FLATTEN
 ON (POS_INV_FACT_ROLLUP.WM_ITEM_NBR = ITEM_FLATTEN.WM_ITEM_NBR)
 LEFT JOIN 8N_POS_INV_DASHBOARD_CUBE.WM_M_CAL_WEEK_2 WM_M_CAL_WEEK_2
 ON (POS_INV_FACT_ROLLUP.WM_WK = WM_M_CAL_WEEK_2.WM_WK) WHERE WM_M_CAL_WEEK_2.WM_WK = 201634
  GROUP BY STORE_FLATTENED.CLX_IRI_MARKET_AREA
 ,STORE_FLATTENED.IDR_DFLT_WHSE
 ,POS_INV_FACT_ROLLUP.SALES_AMT_LAST_WK
 ,ITEM_FLATTEN.SUPPLIER
)    ~ 6 s 

Ran a select count(*) to make sure that all records are processed (removed limit condition)


BOTTOM LINE :
1.Most queries irrespective of whether its partitioned or not perform reasonably once they are cached
2.partitioned column filters perform reasonably well even if they are not cached since the predicate push down filters it at file level
3.filters on non partitioned column performs badly once we remove caching as it scans the complete hive table
4. Also observation that HiveExplain plan for query1 vs query2 : The query optimization internally does not take place 
and hive scans all rows in Query1 ( atleast according to explain plan) whereas in spark from Plan its not evident. But from execution
it seems that the scan is limited to partitioned rows 